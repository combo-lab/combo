{
  "version": 3,
  "sources": ["../../assets/src/socket/index.js", "../../assets/src/socket/constants.js", "../../assets/src/socket/utils.js", "../../assets/src/socket/ajax.js", "../../assets/src/socket/push.js", "../../assets/src/socket/timer.js", "../../assets/src/socket/channel.js", "../../assets/src/socket/longpoll.js", "../../assets/src/socket/serializer.js", "../../assets/src/socket/socket.js", "../../assets/src/socket/presence.js"],
  "sourcesContent": ["/**\n * JavaScript client for Combo.Socket\n *\n * ## Socket Connection\n *\n * A single connection is established to the server and channels are multiplexed\n * over the connection.\n *\n * Connect to the server using the `Socket` class:\n *\n * ```javascript\n * let socket = new Socket(\"/socket\", {params: {userToken: \"123\"}})\n * socket.connect()\n * ```\n *\n * The `Socket` constructor takes the mount point of the socket,\n * the authentication params, as well as options that can be found in\n * the Socket docs, such as configuring the `LongPoll` transport, and\n * heartbeat.\n *\n * ## Channels\n *\n * Channels are isolated, concurrent processes on the server that\n * subscribe to topics and broker events between the client and server.\n * To join a channel, you must provide the topic, and channel params for\n * authorization. Here's an example chat room example where `\"new_msg\"`\n * events are listened for, messages are pushed to the server, and\n * the channel is joined with ok/error/timeout matches:\n *\n * ```\n * let channel = socket.channel(\"room:123\", {token: roomToken})\n * channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n * $input.onEnter( e => {\n *   channel.push(\"new_msg\", {body: e.target.val}, 10000)\n *     .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n *     .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n *     .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n * })\n *\n * channel.join()\n *   .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n *   .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n *   .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\"))\n *```\n *\n * ## Joining\n *\n * Creating a channel with `socket.channel(topic, params)`, binds the params to\n * `channel.params`, which are sent up on `channel.join()`.\n * Subsequent rejoins will send up the modified params for\n * updating authorization params, or passing up last_message_id information.\n * Successful joins receive an \"ok\" status, while unsuccessful joins\n * receive \"error\".\n *\n * With the default serializers and WebSocket transport, JSON text frames are\n * used for pushing a JSON object literal. If an `ArrayBuffer` instance is provided,\n * binary encoding will be used and the message will be sent with the binary\n * opcode.\n *\n * *Note*: binary messages are only supported on the WebSocket transport.\n *\n * ## Duplicate Join Subscriptions\n *\n * While the client may join any number of topics on any number of channels,\n * the client may only hold a single subscription for each unique topic at any\n * given time. When attempting to create a duplicate subscription,\n * the server will close the existing channel, log a warning, and\n * spawn a new channel for the topic. The client will have their\n * `channel.onClose` callbacks fired for the existing channel, and the new\n * channel join will have its receive hooks processed as normal.\n *\n * ## Pushing Messages\n *\n * From the previous example, we can see that pushing messages to the server\n * can be done with `channel.push(eventName, payload)` and we can optionally\n * receive responses from the push. Additionally, we can use\n * `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n *  and take action after some period of waiting. The default timeout is 10000ms.\n *\n *\n * ## Socket Hooks\n *\n * Lifecycle events of the multiplexed connection can be hooked into via\n * `socket.onError()` and `socket.onClose()` events, ie:\n *\n * ```\n * socket.onError( () => console.log(\"there was an error with the connection!\") )\n * socket.onClose( () => console.log(\"the connection dropped\") )\n * ```\n *\n *\n * ## Channel Hooks\n *\n * For each joined channel, you can bind to `onError` and `onClose` events\n * to monitor the channel lifecycle, ie:\n *\n * ```\n * channel.onError( () => console.log(\"there was an error!\") )\n * channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n * ```\n *\n * ### onError hooks\n *\n * `onError` hooks are invoked if the socket connection drops, or the channel\n * crashes on the server. In either case, a channel rejoin is attempted\n * automatically in an exponential backoff manner.\n *\n * ### onClose hooks\n *\n * `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n * closed on the server, or 2). The client explicitly closed, by calling\n * `channel.leave()`\n *\n *\n * ## Presence\n *\n * The `Presence` object provides features for syncing presence information\n * from the server with the client and handling presences joining and leaving.\n *\n * ### Syncing state from the server\n *\n * To sync presence state from the server, first instantiate an object and\n * pass your channel in to track lifecycle events:\n *\n * ```\n * let channel = socket.channel(\"some:topic\")\n * let presence = new Presence(channel)\n * ```\n *\n * Next, use the `presence.onSync` callback to react to state changes\n * from the server. For example, to render the list of users every time\n * the list changes, you could write:\n *\n * ```\n * presence.onSync(() => {\n *   myRenderUsersFunction(presence.list())\n * })\n * ```\n *\n * ### Listing Presences\n *\n * `presence.list` is used to return a list of presence information\n * based on the local state of metadata. By default, all presence\n * metadata is returned, but a `listBy` function can be supplied to\n * allow the client to select which metadata to use for a given presence.\n * For example, you may have a user online from different devices with\n * a metadata status of \"online\", but they have set themselves to \"away\"\n * on another device. In this case, the app may choose to use the \"away\"\n * status for what appears on the UI. The example below defines a `listBy`\n * function which prioritizes the first metadata which was registered for\n * each user. This could be the first tab they opened, or the first device\n * they came online from:\n *\n * ```\n * let listBy = (id, {metas: [first, ...rest]}) => {\n *   first.count = rest.length + 1 // count of this user's presences\n *   first.id = id\n *   return first\n * }\n * let onlineUsers = presence.list(listBy)\n * ```\n *\n * ### Handling individual presence join and leave events\n *\n * The `presence.onJoin` and `presence.onLeave` callbacks can be used to\n * react to individual presences joining and leaving the app. For example:\n *\n * ```\n * let presence = new Presence(channel)\n *\n * // detect if user has joined for the 1st time or from another tab/device\n * presence.onJoin((id, current, newPres) => {\n *   if(!current){\n *     console.log(\"user has entered for the first time\", newPres)\n *   } else {\n *     console.log(\"user additional presence\", newPres)\n *   }\n * })\n *\n * // detect if user has left from all tabs/devices, or is still present\n * presence.onLeave((id, current, leftPres) => {\n *   if(current.metas.length === 0){\n *     console.log(\"user has left from all devices\", leftPres)\n *   } else {\n *     console.log(\"user left from a device\", leftPres)\n *   }\n * })\n * // receive presence data from server\n * presence.onSync(() => {\n *   displayUsers(presence.list())\n * })\n * ```\n * @module socket\n */\n\nimport Socket from './socket'\nimport Channel from './channel'\nimport LongPoll from './longpoll'\nimport Presence from './presence'\nimport Serializer from './serializer'\n\nexport { Socket, Channel, LongPoll, Presence, Serializer }\n", "export const globalSelf = typeof self !== 'undefined' ? self : null\nexport const comboWindow = typeof window !== 'undefined' ? window : null\nexport const global = globalSelf || comboWindow || globalThis\nexport const DEFAULT_VSN = '2.0.0'\nexport const SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 }\nexport const DEFAULT_TIMEOUT = 10000\nexport const WS_CLOSE_NORMAL = 1000\nexport const CHANNEL_STATES = {\n  closed: 'closed',\n  errored: 'errored',\n  joined: 'joined',\n  joining: 'joining',\n  leaving: 'leaving',\n}\nexport const CHANNEL_EVENTS = {\n  close: 'phx_close',\n  error: 'phx_error',\n  join: 'phx_join',\n  reply: 'phx_reply',\n  leave: 'phx_leave',\n}\n\nexport const TRANSPORTS = {\n  longpoll: 'longpoll',\n  websocket: 'websocket',\n}\nexport const XHR_STATES = {\n  complete: 4,\n}\nexport const AUTH_TOKEN_PREFIX = 'base64url.bearer.combo.'\n", "// wraps value in closure or returns closure\nexport let closure = (value) => {\n  if (typeof value === 'function') {\n    return value\n  } else {\n    let closure = function () {\n      return value\n    }\n    return closure\n  }\n}\n", "import { global, XHR_STATES } from './constants'\n\nexport default class Ajax {\n  static request(method, endPoint, headers, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new global.XDomainRequest() // IE8, IE9\n      return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback)\n    } else if (global.XMLHttpRequest) {\n      let req = new global.XMLHttpRequest() // IE7+, Firefox, Chrome, Opera, Safari\n      return this.xhrRequest(req, method, endPoint, headers, body, timeout, ontimeout, callback)\n    } else if (global.fetch && global.AbortController) {\n      // Fetch with AbortController for modern browsers\n      return this.fetchRequest(method, endPoint, headers, body, timeout, ontimeout, callback)\n    } else {\n      throw new Error('No suitable XMLHttpRequest implementation found')\n    }\n  }\n\n  static fetchRequest(method, endPoint, headers, body, timeout, ontimeout, callback) {\n    let options = {\n      method,\n      headers,\n      body,\n    }\n    let controller = null\n    if (timeout) {\n      controller = new AbortController()\n      const _timeoutId = setTimeout(() => controller.abort(), timeout)\n      options.signal = controller.signal\n    }\n    global\n      .fetch(endPoint, options)\n      .then(response => response.text())\n      .then(data => this.parseJSON(data))\n      .then(data => callback && callback(data))\n      .catch((err) => {\n        if (err.name === 'AbortError' && ontimeout) {\n          ontimeout()\n        } else {\n          callback && callback(null)\n        }\n      })\n    return controller\n  }\n\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout\n    req.open(method, endPoint)\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText)\n      callback && callback(response)\n    }\n    if (ontimeout) {\n      req.ontimeout = ontimeout\n    }\n\n    // Work around bug in IE9 that requires an attached onprogress handler\n    req.onprogress = () => {}\n\n    req.send(body)\n    return req\n  }\n\n  static xhrRequest(req, method, endPoint, headers, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true)\n    req.timeout = timeout\n    for (let [key, value] of Object.entries(headers)) {\n      req.setRequestHeader(key, value)\n    }\n    req.onerror = () => callback && callback(null)\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        let response = this.parseJSON(req.responseText)\n        callback(response)\n      }\n    }\n    if (ontimeout) {\n      req.ontimeout = ontimeout\n    }\n\n    req.send(body)\n    return req\n  }\n\n  static parseJSON(resp) {\n    if (!resp || resp === '') {\n      return null\n    }\n\n    try {\n      return JSON.parse(resp)\n    } catch {\n      console && console.log('failed to parse JSON response', resp)\n      return null\n    }\n  }\n\n  static serialize(obj, parentKey) {\n    let queryStr = []\n    for (var key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue\n      }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key\n      let paramVal = obj[key]\n      if (typeof paramVal === 'object') {\n        queryStr.push(this.serialize(paramVal, paramKey))\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + '=' + encodeURIComponent(paramVal))\n      }\n    }\n    return queryStr.join('&')\n  }\n\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n\n    let prefix = url.match(/\\?/) ? '&' : '?'\n    return `${url}${prefix}${this.serialize(params)}`\n  }\n}\n", "/**\n * Initializes the Push\n * @param {Channel} channel - The Channel\n * @param {string} event - The event, for example `\"phx_join\"`\n * @param {Object} payload - The payload, for example `{user_id: 123}`\n * @param {number} timeout - The push timeout in milliseconds\n */\nexport default class Push {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel\n    this.event = event\n    this.payload\n      = payload\n        || function () {\n          return {}\n        }\n    this.receivedResp = null\n    this.timeout = timeout\n    this.timeoutTimer = null\n    this.recHooks = []\n    this.sent = false\n  }\n\n  /**\n   *\n   * @param {number} timeout\n   */\n  resend(timeout) {\n    this.timeout = timeout\n    this.reset()\n    this.send()\n  }\n\n  /**\n   *\n   */\n  send() {\n    if (this.hasReceived('timeout')) {\n      return\n    }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef(),\n    })\n  }\n\n  /**\n   *\n   * @param {*} status\n   * @param {*} callback\n   */\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response)\n    }\n\n    this.recHooks.push({ status, callback })\n    return this\n  }\n\n  /**\n   * @private\n   */\n  reset() {\n    this.cancelRefEvent()\n    this.ref = null\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n  }\n\n  /**\n   * @private\n   */\n  matchReceive({ status, response, _ref }) {\n    this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response))\n  }\n\n  /**\n   * @private\n   */\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return\n    }\n    this.channel.off(this.refEvent)\n  }\n\n  /**\n   * @private\n   */\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n\n  /**\n   * @private\n   */\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout()\n    }\n    this.ref = this.channel.socket.makeRef()\n    this.refEvent = this.channel.replyEventName(this.ref)\n\n    this.channel.on(this.refEvent, (payload) => {\n      this.cancelRefEvent()\n      this.cancelTimeout()\n      this.receivedResp = payload\n      this.matchReceive(payload)\n    })\n\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger('timeout', {})\n    }, this.timeout)\n  }\n\n  /**\n   * @private\n   */\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status\n  }\n\n  /**\n   * @private\n   */\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, { status, response })\n  }\n}\n", "/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * @example\n * let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *   return [1000, 5000, 10000][tries - 1] || 10000\n * })\n * reconnectTimer.scheduleTimeout() // fires after 1000\n * reconnectTimer.scheduleTimeout() // fires after 5000\n * reconnectTimer.reset()\n * reconnectTimer.scheduleTimeout() // fires after 1000\n *\n * @param {Function} callback\n * @param {Function} timerCalc\n */\nexport default class Timer {\n  constructor(callback, timerCalc) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n    this.timer = null\n    this.tries = 0\n  }\n\n  reset() {\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  /**\n   * Cancels any previous scheduleTimeout and schedules callback\n   */\n  scheduleTimeout() {\n    clearTimeout(this.timer)\n\n    this.timer = setTimeout(\n      () => {\n        this.tries = this.tries + 1\n        this.callback()\n      },\n      this.timerCalc(this.tries + 1),\n    )\n  }\n}\n", "import { closure } from './utils'\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './constants'\n\nimport Push from './push'\nimport Timer from './timer'\n\n/**\n *\n * @param {string} topic\n * @param {(Object|function)} params\n * @param {Socket} socket\n */\nexport default class Channel {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed\n    this.topic = topic\n    this.params = closure(params || {})\n    this.socket = socket\n    this.bindings = []\n    this.bindingRef = 0\n    this.timeout = this.socket.timeout\n    this.joinedOnce = false\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout)\n    this.pushBuffer = []\n    this.stateChangeRefs = []\n\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin()\n      }\n    }, this.socket.rejoinAfterMs)\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()))\n    this.stateChangeRefs.push(\n      this.socket.onOpen(() => {\n        this.rejoinTimer.reset()\n        if (this.isErrored()) {\n          this.rejoin()\n        }\n      }),\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach(pushEvent => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this.joinPush.receive('error', () => {\n      this.state = CHANNEL_STATES.errored\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout()\n      }\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      if (this.socket.hasLogger())\n        this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError((reason) => {\n      if (this.socket.hasLogger()) this.socket.log('channel', `error ${this.topic}`, reason)\n      if (this.isJoining()) {\n        this.joinPush.reset()\n      }\n      this.state = CHANNEL_STATES.errored\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout()\n      }\n    })\n    this.joinPush.receive('timeout', () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\n          'channel',\n          `timeout ${this.topic} (${this.joinRef()})`,\n          this.joinPush.timeout,\n        )\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout)\n      leavePush.send()\n      this.state = CHANNEL_STATES.errored\n      this.joinPush.reset()\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout()\n      }\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  /**\n   * Join the channel\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\n        'tried to join multiple times. \\'join\\' can only be called a single time per channel instance',\n      )\n    } else {\n      this.timeout = timeout\n      this.joinedOnce = true\n      this.rejoin()\n      return this.joinPush\n    }\n  }\n\n  /**\n   * Hook into channel close\n   * @param {Function} callback\n   */\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback)\n  }\n\n  /**\n   * Hook into channel errors\n   * @param {Function} callback\n   */\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, reason => callback(reason))\n  }\n\n  /**\n   * Subscribes on channel events\n   *\n   * Subscription returns a ref counter, which can be used later to\n   * unsubscribe the exact event listener\n   *\n   * @example\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * const ref2 = channel.on(\"event\", do_other_stuff)\n   * channel.off(\"event\", ref1)\n   * // Since unsubscription, do_stuff won't fire,\n   * // while do_other_stuff will keep firing on the \"event\"\n   *\n   * @param {string} event\n   * @param {Function} callback\n   * @returns {integer} ref\n   */\n  on(event, callback) {\n    let ref = this.bindingRef++\n    this.bindings.push({ event, ref, callback })\n    return ref\n  }\n\n  /**\n   * Unsubscribes off of channel events\n   *\n   * Use the ref returned from a channel.on() to unsubscribe one\n   * handler, or pass nothing for the ref to unsubscribe all\n   * handlers for the given event.\n   *\n   * @example\n   * // Unsubscribe the do_stuff handler\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * channel.off(\"event\", ref1)\n   *\n   * // Unsubscribe all handlers from event\n   * channel.off(\"event\")\n   *\n   * @param {string} event\n   * @param {integer} ref\n   */\n  off(event, ref) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === 'undefined' || ref === bind.ref))\n    })\n  }\n\n  /**\n   * @private\n   */\n  canPush() {\n    return this.socket.isConnected() && this.isJoined()\n  }\n\n  /**\n   * Sends a message `event` to server with the payload `payload`.\n   * Server receives this in the `handle_in(event, payload, socket)`\n   * function. if server replies or it times out (default 10000ms),\n   * then optionally the reply can be received.\n   *\n   * @example\n   * channel.push(\"event\")\n   *   .receive(\"ok\", payload => console.log(\"server replied:\", payload))\n   *   .receive(\"error\", err => console.log(\"server errored\", err))\n   *   .receive(\"timeout\", () => console.log(\"timed out pushing\"))\n   * @param {string} event\n   * @param {Object} payload\n   * @param {number} [timeout]\n   * @returns {Push}\n   */\n  push(event, payload, timeout = this.timeout) {\n    payload = payload || {}\n    if (!this.joinedOnce) {\n      throw new Error(\n        `tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`,\n      )\n    }\n    let pushEvent = new Push(\n      this,\n      event,\n      function () {\n        return payload\n      },\n      timeout,\n    )\n    if (this.canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /** Leaves the channel\n   *\n   * Unsubscribes from server events, and\n   * instructs channel to terminate on server\n   *\n   * Triggers onClose() hooks\n   *\n   * To receive leave acknowledgements, use the `receive`\n   * hook to bind to the server ack, ie:\n   *\n   * @example\n   * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n   *\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset()\n    this.joinPush.cancelTimeout()\n\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      if (this.socket.hasLogger()) this.socket.log('channel', `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, 'leave')\n    }\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout)\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose())\n    leavePush.send()\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {})\n    }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling\n   * before dispatching to the channel callbacks.\n   *\n   * Must return the payload, modified or unmodified\n   * @param {string} event\n   * @param {Object} payload\n   * @param {integer} ref\n   * @returns {Object}\n   */\n  onMessage(_event, payload, _ref) {\n    return payload\n  }\n\n  /**\n   * @private\n   */\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false\n    }\n\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger())\n        this.socket.log('channel', 'dropping outdated message', {\n          topic,\n          event,\n          payload,\n          joinRef,\n        })\n      return false\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * @private\n   */\n  joinRef() {\n    return this.joinPush.ref\n  }\n\n  /**\n   * @private\n   */\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return\n    }\n    this.socket.leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /**\n   * @private\n   */\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef)\n    if (payload && !handledPayload) {\n      throw new Error(\n        'channel onMessage callbacks must return the payload, modified or unmodified',\n      )\n    }\n\n    let eventBindings = this.bindings.filter(bind => bind.event === event)\n\n    for (let i = 0; i < eventBindings.length; i++) {\n      let bind = eventBindings[i]\n      bind.callback(handledPayload, ref, joinRef || this.joinRef())\n    }\n  }\n\n  /**\n   * @private\n   */\n  replyEventName(ref) {\n    return `chan_reply_${ref}`\n  }\n\n  /**\n   * @private\n   */\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed\n  }\n\n  /**\n   * @private\n   */\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored\n  }\n\n  /**\n   * @private\n   */\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined\n  }\n\n  /**\n   * @private\n   */\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining\n  }\n\n  /**\n   * @private\n   */\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving\n  }\n}\n", "import { SOCKET_STATES, TRANSPORTS, AUTH_TOKEN_PREFIX } from './constants'\n\nimport Ajax from './ajax'\n\nlet arrayBufferToBase64 = (buffer) => {\n  let binary = ''\n  let bytes = new Uint8Array(buffer)\n  let len = bytes.byteLength\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return btoa(binary)\n}\n\nexport default class LongPoll {\n  constructor(endPoint, protocols) {\n    // we only support subprotocols for authToken\n    // [\"combo\", \"base64url.bearer.combo.BASE64_ENCODED_TOKEN\"]\n    if (protocols && protocols.length === 2 && protocols[1].startsWith(AUTH_TOKEN_PREFIX)) {\n      this.authToken = atob(protocols[1].slice(AUTH_TOKEN_PREFIX.length))\n    }\n    this.endPoint = null\n    this.token = null\n    this.skipHeartbeat = true\n    this.reqs = new Set()\n    this.awaitingBatchAck = false\n    this.currentBatch = null\n    this.currentBatchTimer = null\n    this.batchBuffer = []\n    this.onopen = function () {} // noop\n    this.onerror = function () {} // noop\n    this.onmessage = function () {} // noop\n    this.onclose = function () {} // noop\n    this.pollEndpoint = this.normalizeEndpoint(endPoint)\n    this.readyState = SOCKET_STATES.connecting\n    // we must wait for the caller to finish setting up our callbacks and timeout properties\n    setTimeout(() => this.poll(), 0)\n  }\n\n  normalizeEndpoint(endPoint) {\n    return endPoint\n      .replace('ws://', 'http://')\n      .replace('wss://', 'https://')\n      .replace(new RegExp('(.*)/' + TRANSPORTS.websocket), '$1/' + TRANSPORTS.longpoll)\n  }\n\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token })\n  }\n\n  closeAndRetry(code, reason, wasClean) {\n    this.close(code, reason, wasClean)\n    this.readyState = SOCKET_STATES.connecting\n  }\n\n  ontimeout() {\n    this.onerror('timeout')\n    this.closeAndRetry(1005, 'timeout', false)\n  }\n\n  isActive() {\n    return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting\n  }\n\n  poll() {\n    const headers = { Accept: 'application/json' }\n    if (this.authToken) {\n      headers['X-Combo-AuthToken'] = this.authToken\n    }\n    this.ajax(\n      'GET',\n      headers,\n      null,\n      () => this.ontimeout(),\n      (resp) => {\n        if (resp) {\n          var { status, token, messages } = resp\n          this.token = token\n        } else {\n          status = 0\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach((msg) => {\n              // Tasks are what things like event handlers, setTimeout callbacks,\n              // promise resolves and more are run within.\n              // In modern browsers, there are two different kinds of tasks,\n              // microtasks and macrotasks.\n              // Microtasks are mainly used for Promises, while macrotasks are\n              // used for everything else.\n              // Microtasks always have priority over macrotasks. If the JS engine\n              // is looking for a task to run, it will always try to empty the\n              // microtask queue before attempting to run anything from the\n              // macrotask queue.\n              //\n              // For the WebSocket transport, messages always arrive in their own\n              // event. This means that if any promises are resolved from within,\n              // their callbacks will always finish execution by the time the\n              // next message event handler is run.\n              //\n              // In order to emulate this behaviour, we need to make sure each\n              // onmessage handler is run within its own macrotask.\n              setTimeout(() => this.onmessage({ data: msg }), 0)\n            })\n            this.poll()\n            break\n          case 204:\n            this.poll()\n            break\n          case 410:\n            this.readyState = SOCKET_STATES.open\n            this.onopen({})\n            this.poll()\n            break\n          case 403:\n            this.onerror(403)\n            this.close(1008, 'forbidden', false)\n            break\n          case 0:\n          case 500:\n            this.onerror(500)\n            this.closeAndRetry(1011, 'internal server error', 500)\n            break\n          default:\n            throw new Error(`unhandled poll status ${status}`)\n        }\n      },\n    )\n  }\n\n  // we collect all pushes within the current event loop by\n  // setTimeout 0, which optimizes back-to-back procedural\n  // pushes against an empty buffer\n\n  send(body) {\n    if (typeof body !== 'string') {\n      body = arrayBufferToBase64(body)\n    }\n    if (this.currentBatch) {\n      this.currentBatch.push(body)\n    } else if (this.awaitingBatchAck) {\n      this.batchBuffer.push(body)\n    } else {\n      this.currentBatch = [body]\n      this.currentBatchTimer = setTimeout(() => {\n        this.batchSend(this.currentBatch)\n        this.currentBatch = null\n      }, 0)\n    }\n  }\n\n  batchSend(messages) {\n    this.awaitingBatchAck = true\n    this.ajax(\n      'POST',\n      { 'Content-Type': 'application/x-ndjson' },\n      messages.join('\\n'),\n      () => this.onerror('timeout'),\n      (resp) => {\n        this.awaitingBatchAck = false\n        if (!resp || resp.status !== 200) {\n          this.onerror(resp && resp.status)\n          this.closeAndRetry(1011, 'internal server error', false)\n        } else if (this.batchBuffer.length > 0) {\n          this.batchSend(this.batchBuffer)\n          this.batchBuffer = []\n        }\n      },\n    )\n  }\n\n  close(code, reason, wasClean) {\n    for (let req of this.reqs) {\n      req.abort()\n    }\n    this.readyState = SOCKET_STATES.closed\n    let opts = Object.assign(\n      { code: 1000, reason: undefined, wasClean: true },\n      { code, reason, wasClean },\n    )\n    this.batchBuffer = []\n    clearTimeout(this.currentBatchTimer)\n    this.currentBatchTimer = null\n    if (typeof CloseEvent !== 'undefined') {\n      this.onclose(new CloseEvent('close', opts))\n    } else {\n      this.onclose(opts)\n    }\n  }\n\n  ajax(method, headers, body, onCallerTimeout, callback) {\n    let req\n    let ontimeout = () => {\n      this.reqs.delete(req)\n      onCallerTimeout()\n    }\n    req = Ajax.request(\n      method,\n      this.endpointURL(),\n      headers,\n      body,\n      this.timeout,\n      ontimeout,\n      (resp) => {\n        this.reqs.delete(req)\n        if (this.isActive()) {\n          callback(resp)\n        }\n      },\n    )\n    this.reqs.add(req)\n  }\n}\n", "/* The default serializer for encoding and decoding messages */\nimport { CHANNEL_EVENTS } from './constants'\n\nexport default {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\n\n  encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg))\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload]\n      return callback(JSON.stringify(payload))\n    }\n  },\n\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload))\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload)\n      return callback({ join_ref, ref, topic, event, payload })\n    }\n  },\n\n  // private\n\n  binaryEncode(message) {\n    let { join_ref, ref, event, topic, payload } = message\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength)\n    let view = new DataView(header)\n    let offset = 0\n\n    view.setUint8(offset++, this.KINDS.push) // kind\n    view.setUint8(offset++, join_ref.length)\n    view.setUint8(offset++, ref.length)\n    view.setUint8(offset++, topic.length)\n    view.setUint8(offset++, event.length)\n    Array.from(join_ref, char => view.setUint8(offset++, char.charCodeAt(0)))\n    Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)))\n    Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)))\n    Array.from(event, char => view.setUint8(offset++, char.charCodeAt(0)))\n\n    var combined = new Uint8Array(header.byteLength + payload.byteLength)\n    combined.set(new Uint8Array(header), 0)\n    combined.set(new Uint8Array(payload), header.byteLength)\n\n    return combined.buffer\n  },\n\n  binaryDecode(buffer) {\n    let view = new DataView(buffer)\n    let kind = view.getUint8(0)\n    let decoder = new TextDecoder()\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder)\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder)\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder)\n    }\n  },\n\n  decodePush(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1)\n    let topicSize = view.getUint8(2)\n    let eventSize = view.getUint8(3)\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1 // pushes have no ref\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize))\n    offset = offset + joinRefSize\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    let data = buffer.slice(offset, buffer.byteLength)\n    return { join_ref: joinRef, ref: null, topic: topic, event: event, payload: data }\n  },\n\n  decodeReply(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1)\n    let refSize = view.getUint8(2)\n    let topicSize = view.getUint8(3)\n    let eventSize = view.getUint8(4)\n    let offset = this.HEADER_LENGTH + this.META_LENGTH\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize))\n    offset = offset + joinRefSize\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize))\n    offset = offset + refSize\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    let data = buffer.slice(offset, buffer.byteLength)\n    let payload = { status: event, response: data }\n    return {\n      join_ref: joinRef,\n      ref: ref,\n      topic: topic,\n      event: CHANNEL_EVENTS.reply,\n      payload: payload,\n    }\n  },\n\n  decodeBroadcast(buffer, view, decoder) {\n    let topicSize = view.getUint8(1)\n    let eventSize = view.getUint8(2)\n    let offset = this.HEADER_LENGTH + 2\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    let data = buffer.slice(offset, buffer.byteLength)\n\n    return { join_ref: null, ref: null, topic: topic, event: event, payload: data }\n  },\n}\n", "import {\n  global,\n  comboWindow,\n  CHANNEL_EVENTS,\n  DEFAULT_TIMEOUT,\n  DEFAULT_VSN,\n  SOCKET_STATES,\n  TRANSPORTS,\n  WS_CLOSE_NORMAL,\n  AUTH_TOKEN_PREFIX,\n} from './constants'\n\nimport { closure } from './utils'\n\nimport Ajax from './ajax'\nimport Channel from './channel'\nimport LongPoll from './longpoll'\nimport Serializer from './serializer'\nimport Timer from './timer'\n\n/** Initializes the Socket *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} [opts] - Optional configuration\n * @param {Function} [opts.transport] - The transport, for example WebSocket or LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback if WebSocket is not defined.\n * To fallback to LongPoll when WebSocket attempts fail, use `longPollFallbackMs: 2500`.\n *\n * @param {number} [opts.longPollFallbackMs] - The millisecond time to attempt the primary transport\n * before falling back to the LongPoll transport. Disabled by default.\n *\n * @param {boolean} [opts.debug] - When true, enables debug logging. Default false.\n *\n * @param {Function} [opts.encode] - The function to encode outgoing messages.\n *\n * Defaults to JSON encoder.\n *\n * @param {Function} [opts.decode] - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message\n * @param {Function} [opts.reconnectAfterMs] - The optional function that returns the\n * socket reconnect interval, in milliseconds.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n * function(tries){\n *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n * }\n * ````\n *\n * @param {Function} [opts.rejoinAfterMs] - The optional function that returns the millisec\n * rejoin interval for individual channels.\n *\n * ```javascript\n * function(tries){\n *   return [1000, 2000, 5000][tries - 1] || 10000\n * }\n * ````\n *\n * @param {Function} [opts.logger] - The optional function for specialized logging, ie:\n *\n * ```javascript\n * function(kind, msg, data) {\n *   console.log(`${kind}: ${msg}`, data)\n * }\n * ```\n *\n * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {(Object|function)} [opts.params] - The optional params to pass when connecting\n * @param {string} [opts.authToken] - the optional authentication token to be exposed on the server\n * under the `:auth_token` connect_info key.\n * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.\n *\n * Defaults to \"arraybuffer\"\n *\n * @param {vsn} [opts.vsn] - The serializer's protocol version to send on connect.\n *\n * Defaults to DEFAULT_VSN.\n *\n * @param {Object} [opts.sessionStorage] - An optional Storage compatible object\n * Combo uses sessionStorage for longpoll fallback history. Overriding the store is\n * useful when Combo won't have access to `sessionStorage`. For example, This could\n * happen if a site loads a cross-domain channel in an iframe. Example usage:\n *\n *     class InMemoryStorage {\n *       constructor() { this.storage = {} }\n *       getItem(keyName) { return this.storage[keyName] || null }\n *       removeItem(keyName) { delete this.storage[keyName] }\n *       setItem(keyName, keyValue) { this.storage[keyName] = keyValue }\n *     }\n *\n */\nexport default class Socket {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] }\n    this.channels = []\n    this.sendBuffer = []\n    this.ref = 0\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT\n    this.transport = opts.transport || global.WebSocket || LongPoll\n    this.primaryPassedHealthCheck = false\n    this.longPollFallbackMs = opts.longPollFallbackMs\n    this.fallbackTimer = null\n    this.sessionStore = opts.sessionStorage || (global && global.sessionStorage)\n    this.establishedConnections = 0\n    this.defaultEncoder = Serializer.encode.bind(Serializer)\n    this.defaultDecoder = Serializer.decode.bind(Serializer)\n    this.closeWasClean = false\n    this.disconnecting = false\n    this.binaryType = opts.binaryType || 'arraybuffer'\n    this.connectClock = 1\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder\n      this.decode = opts.decode || this.defaultDecoder\n    } else {\n      this.encode = this.defaultEncoder\n      this.decode = this.defaultDecoder\n    }\n    let awaitingConnectionOnPageShow = null\n    if (comboWindow && comboWindow.addEventListener) {\n      comboWindow.addEventListener('pagehide', (_e) => {\n        if (this.conn) {\n          this.disconnect()\n          awaitingConnectionOnPageShow = this.connectClock\n        }\n      })\n      comboWindow.addEventListener('pageshow', (_e) => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null\n          this.connect()\n        }\n      })\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000\n    this.rejoinAfterMs = (tries) => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries)\n      } else {\n        return [1000, 2000, 5000][tries - 1] || 10000\n      }\n    }\n    this.reconnectAfterMs = (tries) => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries)\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n      }\n    }\n    this.logger = opts.logger || null\n    if (!this.logger && opts.debug) {\n      this.logger = (kind, msg, data) => {\n        console.log(`${kind}: ${msg}`, data)\n      }\n    }\n    this.longpollerTimeout = opts.longpollerTimeout || 20000\n    this.params = closure(opts.params || {})\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n    this.vsn = opts.vsn || DEFAULT_VSN\n    this.heartbeatTimeoutTimer = null\n    this.heartbeatTimer = null\n    this.pendingHeartbeatRef = null\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect())\n    }, this.reconnectAfterMs)\n    this.authToken = opts.authToken\n  }\n\n  /**\n   * Returns the LongPoll transport reference\n   */\n  getLongPollTransport() {\n    return LongPoll\n  }\n\n  /**\n   * Disconnects and replaces the active transport\n   *\n   * @param {Function} newTransport - The new transport class to instantiate\n   *\n   */\n  replaceTransport(newTransport) {\n    this.connectClock++\n    this.closeWasClean = true\n    clearTimeout(this.fallbackTimer)\n    this.reconnectTimer.reset()\n    if (this.conn) {\n      this.conn.close()\n      this.conn = null\n    }\n    this.transport = newTransport\n  }\n\n  /**\n   * Returns the socket protocol\n   *\n   * @returns {string}\n   */\n  protocol() {\n    return location.protocol.match(/^https/) ? 'wss' : 'ws'\n  }\n\n  /**\n   * The fully qualified socket url\n   *\n   * @returns {string}\n   */\n  endPointURL() {\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), {\n      vsn: this.vsn,\n    })\n    if (uri.charAt(0) !== '/') {\n      return uri\n    }\n    if (uri.charAt(1) === '/') {\n      return `${this.protocol()}:${uri}`\n    }\n\n    return `${this.protocol()}://${location.host}${uri}`\n  }\n\n  /**\n   * Disconnects the socket\n   *\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.\n   *\n   * @param {Function} callback - Optional callback which is called after socket is disconnected.\n   * @param {integer} code - A status code for disconnection (Optional).\n   * @param {string} reason - A textual description of the reason to disconnect. (Optional)\n   */\n  disconnect(callback, code, reason) {\n    this.connectClock++\n    this.disconnecting = true\n    this.closeWasClean = true\n    clearTimeout(this.fallbackTimer)\n    this.reconnectTimer.reset()\n    this.teardown(\n      () => {\n        this.disconnecting = false\n        callback && callback()\n      },\n      code,\n      reason,\n    )\n  }\n\n  /**\n   *\n   * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\n   *\n   * Passing params to connect is deprecated; pass them in the Socket constructor instead:\n   * `new Socket(\"/socket\", {params: {user_id: userToken}})`.\n   */\n  connect(params) {\n    if (params) {\n      console\n      && console.log(\n        'passing params to connect is deprecated. Instead pass :params to the Socket constructor',\n      )\n      this.params = closure(params)\n    }\n    if (this.conn && !this.disconnecting) {\n      return\n    }\n    if (this.longPollFallbackMs && this.transport !== LongPoll) {\n      this.connectWithFallback(LongPoll, this.longPollFallbackMs)\n    } else {\n      this.transportConnect()\n    }\n  }\n\n  /**\n   * Logs the message. Override `this.logger` for specialized logging. noops by default\n   * @param {string} kind\n   * @param {string} msg\n   * @param {Object} data\n   */\n  log(kind, msg, data) {\n    this.logger && this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns true if a logger has been set on this socket.\n   */\n  hasLogger() {\n    return this.logger !== null\n  }\n\n  /**\n   * Registers callbacks for connection open events\n   *\n   * @example socket.onOpen(function(){ console.info(\"the socket was opened\") })\n   *\n   * @param {Function} callback\n   */\n  onOpen(callback) {\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.open.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Registers callbacks for connection close events\n   * @param {Function} callback\n   */\n  onClose(callback) {\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.close.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Registers callbacks for connection error events\n   *\n   * @example socket.onError(function(error){ alert(\"An error occurred\") })\n   *\n   * @param {Function} callback\n   */\n  onError(callback) {\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.error.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Registers callbacks for connection message events\n   * @param {Function} callback\n   */\n  onMessage(callback) {\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.message.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Pings the server and invokes the callback with the RTT in milliseconds\n   * @param {Function} callback\n   *\n   * Returns true if the ping was pushed or false if unable to be pushed.\n   */\n  ping(callback) {\n    if (!this.isConnected()) {\n      return false\n    }\n    let ref = this.makeRef()\n    let startTime = Date.now()\n    this.push({ topic: 'combo', event: 'heartbeat', payload: {}, ref: ref })\n    let onMsgRef = this.onMessage((msg) => {\n      if (msg.ref === ref) {\n        this.off([onMsgRef])\n        callback(Date.now() - startTime)\n      }\n    })\n    return true\n  }\n\n  /**\n   * @private\n   */\n\n  transportConnect() {\n    this.connectClock++\n    this.closeWasClean = false\n    let protocols = undefined\n    // Sec-WebSocket-Protocol based token\n    // (longpoll uses Authorization header instead)\n    if (this.authToken) {\n      protocols = ['combo', `${AUTH_TOKEN_PREFIX}${btoa(this.authToken).replace(/=/g, '')}`]\n    }\n    this.conn = new this.transport(this.endPointURL(), protocols)\n    this.conn.binaryType = this.binaryType\n    this.conn.timeout = this.longpollerTimeout\n    this.conn.onopen = () => this.onConnOpen()\n    this.conn.onerror = error => this.onConnError(error)\n    this.conn.onmessage = event => this.onConnMessage(event)\n    this.conn.onclose = event => this.onConnClose(event)\n  }\n\n  getSession(key) {\n    return this.sessionStore && this.sessionStore.getItem(key)\n  }\n\n  storeSession(key, val) {\n    this.sessionStore && this.sessionStore.setItem(key, val)\n  }\n\n  connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {\n    clearTimeout(this.fallbackTimer)\n    let established = false\n    let primaryTransport = true\n    let openRef, errorRef\n    let fallback = (reason) => {\n      this.log('transport', `falling back to ${fallbackTransport.name}...`, reason)\n      this.off([openRef, errorRef])\n      primaryTransport = false\n      this.replaceTransport(fallbackTransport)\n      this.transportConnect()\n    }\n    if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {\n      return fallback('memorized')\n    }\n\n    this.fallbackTimer = setTimeout(fallback, fallbackThreshold)\n\n    errorRef = this.onError((reason) => {\n      this.log('transport', 'error', reason)\n      if (primaryTransport && !established) {\n        clearTimeout(this.fallbackTimer)\n        fallback(reason)\n      }\n    })\n    this.onOpen(() => {\n      established = true\n      if (!primaryTransport) {\n        // only memorize LP if we never connected to primary\n        if (!this.primaryPassedHealthCheck) {\n          this.storeSession(`phx:fallback:${fallbackTransport.name}`, 'true')\n        }\n        return this.log('transport', `established ${fallbackTransport.name} fallback`)\n      }\n      // if we've established primary, give the fallback a new period to attempt ping\n      clearTimeout(this.fallbackTimer)\n      this.fallbackTimer = setTimeout(fallback, fallbackThreshold)\n      this.ping((rtt) => {\n        this.log('transport', 'connected to primary after', rtt)\n        this.primaryPassedHealthCheck = true\n        clearTimeout(this.fallbackTimer)\n      })\n    })\n    this.transportConnect()\n  }\n\n  clearHeartbeats() {\n    clearTimeout(this.heartbeatTimer)\n    clearTimeout(this.heartbeatTimeoutTimer)\n  }\n\n  onConnOpen() {\n    if (this.hasLogger())\n      this.log('transport', `${this.transport.name} connected to ${this.endPointURL()}`)\n    this.closeWasClean = false\n    this.disconnecting = false\n    this.establishedConnections++\n    this.flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.resetHeartbeat()\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback())\n  }\n\n  /**\n   * @private\n   */\n\n  heartbeatTimeout() {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      if (this.hasLogger()) {\n        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection')\n      }\n      this.triggerChanError()\n      this.closeWasClean = false\n      this.teardown(\n        () => this.reconnectTimer.scheduleTimeout(),\n        WS_CLOSE_NORMAL,\n        'heartbeat timeout',\n      )\n    }\n  }\n\n  resetHeartbeat() {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return\n    }\n    this.pendingHeartbeatRef = null\n    this.clearHeartbeats()\n    this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs)\n  }\n\n  teardown(callback, code, reason) {\n    if (!this.conn) {\n      return callback && callback()\n    }\n    let connectClock = this.connectClock\n\n    this.waitForBufferDone(() => {\n      if (connectClock !== this.connectClock) {\n        return\n      }\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || '')\n        } else {\n          this.conn.close()\n        }\n      }\n\n      this.waitForSocketClosed(() => {\n        if (connectClock !== this.connectClock) {\n          return\n        }\n        if (this.conn) {\n          this.conn.onopen = function () {} // noop\n          this.conn.onerror = function () {} // noop\n          this.conn.onmessage = function () {} // noop\n          this.conn.onclose = function () {} // noop\n          this.conn = null\n        }\n\n        callback && callback()\n      })\n    })\n  }\n\n  waitForBufferDone(callback, tries = 1) {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback()\n      return\n    }\n\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1)\n    }, 150 * tries)\n  }\n\n  waitForSocketClosed(callback, tries = 1) {\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n      callback()\n      return\n    }\n\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1)\n    }, 150 * tries)\n  }\n\n  onConnClose(event) {\n    let closeCode = event && event.code\n    if (this.hasLogger()) this.log('transport', 'close', event)\n    this.triggerChanError()\n    this.clearHeartbeats()\n    if (!this.closeWasClean && closeCode !== 1000) {\n      this.reconnectTimer.scheduleTimeout()\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event))\n  }\n\n  /**\n   * @private\n   */\n  onConnError(error) {\n    if (this.hasLogger()) this.log('transport', error)\n    let transportBefore = this.transport\n    let establishedBefore = this.establishedConnections\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore)\n    })\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError()\n    }\n  }\n\n  /**\n   * @private\n   */\n  triggerChanError() {\n    this.channels.forEach((channel) => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error)\n      }\n    })\n  }\n\n  /**\n   * @returns {string}\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return 'connecting'\n      case SOCKET_STATES.open:\n        return 'open'\n      case SOCKET_STATES.closing:\n        return 'closing'\n      default:\n        return 'closed'\n    }\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isConnected() {\n    return this.connectionState() === 'open'\n  }\n\n  /**\n   * @private\n   *\n   * @param {Channel}\n   */\n  remove(channel) {\n    this.off(channel.stateChangeRefs)\n    this.channels = this.channels.filter(c => c !== channel)\n  }\n\n  /**\n   * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.\n   *\n   * @param {refs} - list of refs returned by calls to\n   *                 `onOpen`, `onClose`, `onError,` and `onMessage`\n   */\n  off(refs) {\n    for (let key in this.stateChangeCallbacks) {\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1\n      })\n    }\n  }\n\n  /**\n   * Initiates a new channel for the given topic\n   *\n   * @param {string} topic\n   * @param {Object} chanParams - Parameters for the channel\n   * @returns {Channel}\n   */\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * @param {Object} data\n   */\n  push(data) {\n    if (this.hasLogger()) {\n      let { topic, event, payload, ref, join_ref } = data\n      this.log('push', `${topic} ${event} (${join_ref}, ${ref})`, payload)\n    }\n\n    if (this.isConnected()) {\n      this.encode(data, result => this.conn.send(result))\n    } else {\n      this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)))\n    }\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   * @returns {string}\n   */\n  makeRef() {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  sendHeartbeat() {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return\n    }\n    this.pendingHeartbeatRef = this.makeRef()\n    this.push({\n      topic: 'combo',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.heartbeatTimeoutTimer = setTimeout(\n      () => this.heartbeatTimeout(),\n      this.heartbeatIntervalMs,\n    )\n  }\n\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref, join_ref } = msg\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.clearHeartbeats()\n        this.pendingHeartbeatRef = null\n        this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs)\n      }\n\n      if (this.hasLogger())\n        this.log(\n          'receive',\n          `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`,\n          payload,\n        )\n\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i]\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue\n        }\n        channel.trigger(event, payload, ref, join_ref)\n      }\n\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        let [, callback] = this.stateChangeCallbacks.message[i]\n        callback(msg)\n      }\n    })\n  }\n\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(\n      c => c.topic === topic && (c.isJoined() || c.isJoining()),\n    )\n    if (dupChannel) {\n      if (this.hasLogger()) this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.leave()\n    }\n  }\n}\n", "/**\n * Initializes the Presence\n * @param {Channel} channel - The Channel\n * @param {Object} opts - The options,\n *        for example `{events: {state: \"state\", diff: \"diff\"}}`\n */\nexport default class Presence {\n  constructor(channel, opts = {}) {\n    let events = opts.events || { state: 'presence_state', diff: 'presence_diff' }\n    this.state = {}\n    this.pendingDiffs = []\n    this.channel = channel\n    this.joinRef = null\n    this.caller = {\n      onJoin: function () {},\n      onLeave: function () {},\n      onSync: function () {},\n    }\n\n    this.channel.on(events.state, (newState) => {\n      let { onJoin, onLeave, onSync } = this.caller\n\n      this.joinRef = this.channel.joinRef()\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave)\n\n      this.pendingDiffs.forEach((diff) => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n      })\n      this.pendingDiffs = []\n      onSync()\n    })\n\n    this.channel.on(events.diff, (diff) => {\n      let { onJoin, onLeave, onSync } = this.caller\n\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff)\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n        onSync()\n      }\n    })\n  }\n\n  onJoin(callback) {\n    this.caller.onJoin = callback\n  }\n\n  onLeave(callback) {\n    this.caller.onLeave = callback\n  }\n\n  onSync(callback) {\n    this.caller.onSync = callback\n  }\n\n  list(by) {\n    return Presence.list(this.state, by)\n  }\n\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef()\n  }\n\n  // lower-level public static API\n\n  /**\n   * Used to sync the list of presences on the server\n   * with the client's state. An optional `onJoin` and `onLeave` callback can\n   * be provided to react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @returns {Presence}\n   */\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState)\n    let joins = {}\n    let leaves = {}\n\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence\n      }\n    })\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key]\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map(m => m.phx_ref)\n        let curRefs = currentPresence.metas.map(m => m.phx_ref)\n        let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0)\n        let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0)\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence\n          joins[key].metas = joinedMetas\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence)\n          leaves[key].metas = leftMetas\n        }\n      } else {\n        joins[key] = newPresence\n      }\n    })\n    return this.syncDiff(state, { joins: joins, leaves: leaves }, onJoin, onLeave)\n  }\n\n  /**\n   *\n   * Used to sync a diff of presence join and leave\n   * events from the server, as they happen. Like `syncState`, `syncDiff`\n   * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n   * joining or leaving from a device.\n   *\n   * @returns {Presence}\n   */\n  static syncDiff(state, diff, onJoin, onLeave) {\n    let { joins, leaves } = this.clone(diff)\n    if (!onJoin) {\n      onJoin = function () {}\n    }\n    if (!onLeave) {\n      onLeave = function () {}\n    }\n\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key]\n      state[key] = this.clone(newPresence)\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map(m => m.phx_ref)\n        let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0)\n        state[key].metas.unshift(...curMetas)\n      }\n      onJoin(key, currentPresence, newPresence)\n    })\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key]\n      if (!currentPresence) {\n        return\n      }\n      let refsToRemove = leftPresence.metas.map(m => m.phx_ref)\n      currentPresence.metas = currentPresence.metas.filter((p) => {\n        return refsToRemove.indexOf(p.phx_ref) < 0\n      })\n      onLeave(key, currentPresence, leftPresence)\n      if (currentPresence.metas.length === 0) {\n        delete state[key]\n      }\n    })\n    return state\n  }\n\n  /**\n   * Returns the array of presences, with selected metadata.\n   *\n   * @param {Object} presences\n   * @param {Function} chooser\n   *\n   * @returns {Presence}\n   */\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function (key, pres) {\n        return pres\n      }\n    }\n\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence)\n    })\n  }\n\n  // private\n\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]))\n  }\n\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n}\n"],
  "mappings": "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",
  "names": ["closure"]
}
